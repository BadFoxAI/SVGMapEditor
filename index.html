<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Island Editor - Final Toggle</title>
    <style>
        /* --- CSS Styling --- */
        html, body { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; font-family: sans-serif; background-color: #222; }
        .editor-app { position: relative; width: 100%; height: 100%; display: flex; background-color: #333; }

        /* Toolbar */
        .toolbar { position: fixed; top: 0; left: 0; width: 280px; height: 100%; background-color: #444; border-right: 1px solid #111; box-shadow: 2px 0 8px rgba(0,0,0,0.3); z-index: 100; display: flex; flex-direction: column; transform: translateX(0); transition: transform 0.3s ease-in-out; color: #eee; }
        .editor-app:not(.toolbar-visible) .toolbar { transform: translateX(-100%); } /* Hide based on parent */

        .toolbar-header { padding: 10px 15px; background-color: #555; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid #666;}
        .toolbar-header h2 { margin: 0; font-size: 1.1em; }
        .toolbar-toggle-btn { background: none; border: none; color: #eee; font-size: 1.5em; cursor: pointer; padding: 0 5px; }
        .toolbar-content { padding: 15px; overflow-y: auto; flex-grow: 1; }
        .toolbar-section { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #555; }
        .toolbar-section:last-child { border-bottom: none; margin-bottom: 0; }
        .toolbar-section h3 { margin-top: 0; margin-bottom: 8px; font-size: 1em; color: #ccc; border-bottom: 1px solid #555; padding-bottom: 3px;}
        .toolbar button, .toolbar label, .toolbar input, .toolbar span { font-size: 0.9em; vertical-align: middle; }
        .toolbar button { margin: 3px 2px 3px 0; padding: 5px 10px; background-color: #5a5a5a; border: 1px solid #777; color: #eee; border-radius: 3px; cursor: pointer; }
        .toolbar button:hover { background-color: #666; }
        .toolbar button:disabled { background-color: #4a4a4a; color: #888; cursor: not-allowed; }
        .toolbar button.active { background-color: #77aaff; color: #111; font-weight: bold; }
        .toolbar label { display: block; margin: 8px 0 2px 0; font-size: 0.85em; color: #ccc; }
        .toolbar input[type="number"] { width: 55px; text-align: right; padding: 4px; background-color: #333; border: 1px solid #666; color: #eee; border-radius: 3px; margin-left: 5px;}
        .toolbar input[type="range"] { width: calc(100% - 75px); margin-left: 5px; cursor: pointer; vertical-align: middle;}
        .toolbar .param-group { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px;}
        .toolbar .param-group span { min-width: 35px; text-align: right; font-size: 0.85em; color: #ddd;}

        /* Layer Ramp Styles */
        #layerRampContainer { margin-top: 10px; }
        #layerRamp { position: relative; width: calc(100% - 45px); height: 10px; background: linear-gradient(to right, #808080, #228B22, #8FBC8F, #D2B48C); border: 1px solid #222; border-radius: 5px; cursor: pointer; display: inline-block; vertical-align: middle; }
        .ramp-handle { position: absolute; top: -3px; width: 8px; height: 16px; background-color: #ddd; border: 1px solid #333; border-radius: 2px; cursor: ew-resize; z-index: 10; box-shadow: 0 0 3px rgba(0,0,0,0.5); }
        #handleStone { background-color: #a0a0a0; } #handleForest { background-color: #5db35d; } #handleGrass { background-color: #b2d8b2; }
        .ramp-percentage { display: inline-block; width: 40px; text-align: right; font-size: 0.85em; margin-left: 5px; vertical-align: middle; }
        .ramp-label { display: block; font-size: 0.8em; color: #aaa; margin-top: 2px; text-align: center;}

        /* Canvas & Status Bar */
        #canvasContainer { flex-grow: 1; overflow: hidden; position: relative; cursor: grab; transition: margin-left 0.3s ease-in-out; margin-left: 0; }
        .editor-app.toolbar-visible #canvasContainer { margin-left: 280px; }
        #editorCanvas { display: block; background-color: #6495ED; }
        #status { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.6); color: #eee; padding: 4px 10px; font-size: 0.85em; z-index: 90; display: flex; gap: 15px; transition: left 0.3s ease-in-out; }
        .editor-app.toolbar-visible #status { left: 280px; }

        /* Toolbar Open Button */
        #toolbarOpenBtn {
            position: fixed; /* Use fixed to stay relative to viewport */
            top: 10px; left: 10px; z-index: 101; background: #555; color: #eee; border: 1px solid #777; border-radius: 3px; font-size: 1.2em; padding: 3px 8px; cursor: pointer;
            display: none; /* Hide by default */
            box-shadow: 1px 1px 5px rgba(0,0,0,0.4);
         }
        /* Show Open Button only when toolbar is hidden */
        .editor-app:not(.toolbar-visible) #toolbarOpenBtn { display: block; }

        /* Misc */
        .handle { fill: rgba(255, 255, 0, 0.8); stroke: rgba(0, 0, 0, 0.7); stroke-width: 1; }
        .handle.rotate { fill: rgba(0, 200, 255, 0.8); }
        #loadFile { display: none; }
    </style>
</head>
<body>
    <!-- Main App Container -->
    <div id="editorApp" class="editor-app toolbar-visible"> <!-- Start visible -->

        <!-- Open Button (Inside App, Outside Toolbar) -->
        <button id="toolbarOpenBtn" title="Open Toolbar [ T ]">☰</button>

        <!-- Toolbar -->
        <div id="toolbar" class="toolbar">
            <div class="toolbar-header"><h2>Island Editor</h2><button id="toolbarCloseBtn" class="toolbar-toggle-btn" title="Close Toolbar [ T ]">✕</button></div>
            <div class="toolbar-content">
                 <!-- Actions Section -->
                 <div class="toolbar-section"><h3>Actions</h3><button id="addIslandBtn" title="Place New Island [ P ]">Place New Island</button><button id="removeIslandBtn" title="Remove Selected [ Delete ]" disabled>Remove Selected</button><hr style="border-color: #555; margin: 8px 0 5px;"><button id="undoBtn" title="Undo [ Ctrl+Z ]" disabled>Undo</button><button id="redoBtn" title="Redo [ Ctrl+Y ]" disabled>Redo</button></div>
                 <!-- Shape Parameters Section -->
                 <div class="toolbar-section"><h3>Shape Parameters</h3><div class="param-group"><label for="islandPoints" title="Base points before smoothing">Base Pts:</label><input type="number" id="islandPoints" value="16" min="4" max="100"></div><div class="param-group"><label for="islandRadiusNoise" title="Randomness added to radius">Rand Noise:</label><input type="range" id="islandRadiusNoise" min="0.0" max="1.0" value="0.2" step="0.01"><span id="radiusNoiseValue">0.20</span></div><div class="param-group"><label for="islandPerlinAmp" title="Amplitude of Perlin noise variation">Perlin Amp:</label><input type="range" id="islandPerlinAmp" min="0.0" max="2.0" value="0.5" step="0.05"><span id="perlinAmpValue">0.50</span></div><div class="param-group"><label for="islandPerlinFreq" title="Frequency (scale) of Perlin noise">Perlin Freq:</label><input type="range" id="islandPerlinFreq" min="0.1" max="10.0" value="1.5" step="0.1"><span id="perlinFreqValue">1.5</span></div><div class="param-group"><label for="chaikinIterations" title="Number of smoothing passes">Smooth:</label><input type="range" id="chaikinIterations" min="0" max="8" value="4" step="1"><span id="iterationsValue">4</span></div></div>
                 <!-- Layer Ramp Section -->
                  <div class="toolbar-section">
                    <h3>Layer Boundaries</h3>
                    <div id="layerRampContainer">
                         <div id="layerRamp">
                             <div id="handleStone" class="ramp-handle" data-layer="stone"></div>
                             <div id="handleForest" class="ramp-handle" data-layer="forest"></div>
                             <div id="handleGrass" class="ramp-handle" data-layer="grass"></div>
                         </div>
                         <div style="margin-top: 5px; font-size: 0.85em;">
                             <div>Stone: <span id="stoneBoundaryValue" class="ramp-percentage">35%</span></div>
                             <div>Forest: <span id="forestBoundaryValue" class="ramp-percentage">65%</span></div>
                             <div>Grass: <span id="grassBoundaryValue" class="ramp-percentage">85%</span></div>
                             <div style="margin-top:3px;">(Sand: <span id="sandBoundaryValue" class="ramp-percentage">15%</span>)</div> <!-- Implicit Sand -->
                         </div>
                    </div>
                  </div>
                 <!-- View Section -->
                 <div class="toolbar-section"><h3>View</h3><button id="centerViewBtn" title="Center View on Selection or Map [ C ]">Center View</button><button id="fitViewBtn" title="Fit View to All Islands">Fit to View</button></div>
                 <!-- File Section -->
                 <div class="toolbar-section"><h3>File</h3><button id="saveBtn" title="Save complete editor state for later use [ Ctrl+S ]">Save State</button><button id="loadBtn" title="Load editor state from file [ Ctrl+O ]">Load State</button></div>
            </div>
        </div>

        <!-- Canvas Area -->
        <div id="canvasContainer"><canvas id="editorCanvas"></canvas></div>

        <!-- Status Bar -->
        <div id="status"><span>Zoom: <span id="zoomLevel">100%</span></span><span>Coords: <span id="coords">( - , - )</span></span><span>Islands: <span id="islandCount">0</span></span></div>

        <!-- Hidden File Input -->
        <input type="file" id="loadFile" accept=".json, .islandmap">

    </div> <!-- End #editorApp -->

    <!-- Embed noisejs Library -->
    <script> /* ... full noisejs code ... */ (function(global){var module=global.noise={};function Grad(x,y,z){this.x=x;this.y=y;this.z=z}Grad.prototype.dot2=function(x,y){return this.x*x+this.y*y};Grad.prototype.dot3=function(x,y,z){return this.x*x+this.y*y+this.z*z};var grad3=[new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];var p=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];var perm=new Array(512);var gradP=new Array(512);module.seed=function(seed){if(seed>0&&seed<1){seed*=65536}seed=Math.floor(seed);if(seed<256){seed|=seed<<8}for(var i=0;i<256;i++){var v;if(i&1){v=p[i]^(seed&255)}else{v=p[i]^((seed>>8)&255)}perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}};module.seed(0);var F2=0.5*(Math.sqrt(3.0)-1.0),G2=(3.0-Math.sqrt(3.0))/6.0;var F3=1.0/3.0,G3=1.0/6.0;module.simplex2=function(xin,yin){var n0,n1,n2;var s=(xin+yin)*F2;var i=Math.floor(xin+s);var j=Math.floor(yin+s);var t=(i+j)*G2;var x0=xin-i+t;var y0=yin-j+t;var i1,j1;if(x0>y0){i1=1;j1=0}else{i1=0;j1=1}var x1=x0-i1+G2;var y1=y0-j1+G2;var x2=x0-1.0+2.0*G2;var y2=y0-1.0+2.0*G2;i&=255;j&=255;var gi0=gradP[i+perm[j]];var gi1=gradP[i+i1+perm[j+j1]];var gi2=gradP[i+1+perm[j+1]];var t0=0.5-x0*x0-y0*y0;if(t0<0){n0=0.0}else{t0*=t0;n0=t0*t0*gi0.dot2(x0,y0)}var t1=0.5-x1*x1-y1*y1;if(t1<0){n1=0.0}else{t1*=t1;n1=t1*t1*gi1.dot2(x1,y1)}var t2=0.5-x2*x2-y2*y2;if(t2<0){n2=0.0}else{t2*=t2;n2=t2*t2*gi2.dot2(x2,y2)}return 70.0*(n0+n1+n2)};module.perlin2=function(x,y){var X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;var n00=gradP[X+perm[Y]].dot2(x,y);var n01=gradP[X+perm[Y+1]].dot2(x,y-1);var n10=gradP[X+1+perm[Y]].dot2(x-1,y);var n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);var u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))};function fade(t){return t*t*t*(t*(t*6.0-15.0)+10.0)}function lerp(a,b,t){return(1.0-t)*a+t*b}})(window);
    </script>

    <script>
        // Wrap entire script in a try...catch
        try {
            document.addEventListener('DOMContentLoaded', () => {
                console.log("DOM Loaded. Initializing Editor...");

                // --- Config & Constants --- (Keep as is)
                const MAP_WIDTH = 512; const MAP_HEIGHT = 512; const OCEAN_COLOR_HEX = '#6495ED'; const LAYER_COLORS = { sand: '#D2B48C', grass: '#8FBC8F', forest: '#228B22', stone: '#808080', }; const DEFAULT_LAYER_BOUNDARIES = { grass: 85, forest: 65, stone: 35 }; const LAYER_TYPES = ['sand', 'grass', 'forest', 'stone']; const RENDER_ORDER = ['sand', 'grass', 'forest', 'stone']; const SELECTED_OUTLINE_COLOR = 'rgba(255, 255, 0, 0.9)'; const DEFAULT_OUTLINE_COLOR = 'rgba(0, 0, 0, 0.6)'; const PREVIEW_FILL_COLOR = 'rgba(210, 180, 140, 0.6)'; const PREVIEW_OUTLINE_COLOR = 'rgba(255, 255, 255, 0.8)'; const PREVIEW_COLLISION_OUTLINE_COLOR = 'rgba(255, 0, 0, 0.8)'; const SELECTED_OUTLINE_WIDTH_FACTOR = 1.5; const DEFAULT_OUTLINE_WIDTH = 1.0; const MIN_ZOOM = 0.1; const MAX_ZOOM = 10.0; const SCROLL_SENSITIVITY = 0.001; const MIN_POLYGON_POINTS = 3; const HANDLE_SIZE = 8; const HANDLE_COLOR = 'rgba(255, 255, 0, 0.8)'; const ROTATE_HANDLE_COLOR = 'rgba(0, 200, 255, 0.8)'; const HANDLE_STROKE_COLOR = 'rgba(0, 0, 0, 0.7)'; const ROTATE_HANDLE_OFFSET = 20; const UNDO_STACK_LIMIT = 30; const PARAM_UPDATE_THROTTLE_MS = 150; const FIT_VIEW_PADDING_FACTOR = 1.15; const MIN_RAMP_SEPARATION = 2;

                // --- Application State --- (Keep as is)
                let mapData = { width: MAP_WIDTH, height: MAP_HEIGHT, islands: [] }; let view = { scale: 1.0, offsetX: 0, offsetY: 0 }; let selectedIslandId = null; let isPlacingIsland = false; let previewIslandData = { layers: null, center: null, params: null }; let isPreviewColliding = false; let isPanning = false; let isMovingIsland = false; let dragStartCoords = { screen: {x:0, y:0}, world: {x:0, y:0} }; let lastMousePos = { screen: {x:0, y:0}, world: {x:0, y:0} }; let nextIslandId = 0; let isInitialized = false; let activeHandle = null; let dragStartIslandLayers = null; let dragStartIslandCenter = null; let dragStartHandleInfo = { angle: 0, dist: 0 }; let undoStack = []; let redoStack = []; let historyLocked = false; let isDraggingRampHandle = false; let draggedRampHandle = null; let rampDragStartX = 0; let rampWidth = 0; let rampLeft = 0;

                // --- DOM Element References --- (Keep as is)
                const editorApp = document.getElementById('editorApp'); const canvas = document.getElementById('editorCanvas'); const canvasContainer = document.getElementById('canvasContainer'); const toolbar = document.getElementById('toolbar'); const toolbarCloseBtn = document.getElementById('toolbarCloseBtn'); const toolbarOpenBtn = document.getElementById('toolbarOpenBtn'); const addIslandBtn = document.getElementById('addIslandBtn'); const removeIslandBtn = document.getElementById('removeIslandBtn'); const islandPointsInput = document.getElementById('islandPoints'); const islandRadiusNoiseInput = document.getElementById('islandRadiusNoise'); const radiusNoiseValueSpan = document.getElementById('radiusNoiseValue'); const islandPerlinAmpInput = document.getElementById('islandPerlinAmp'); const perlinAmpValueSpan = document.getElementById('perlinAmpValue'); const islandPerlinFreqInput = document.getElementById('islandPerlinFreq'); const perlinFreqValueSpan = document.getElementById('perlinFreqValue'); const chaikinIterationsInput = document.getElementById('chaikinIterations'); const iterationsValueSpan = document.getElementById('iterationsValue'); const layerRampContainer = document.getElementById('layerRampContainer'); const layerRamp = document.getElementById('layerRamp'); const handleStone = document.getElementById('handleStone'); const handleForest = document.getElementById('handleForest'); const handleGrass = document.getElementById('handleGrass'); const stoneBoundaryValueSpan = document.getElementById('stoneBoundaryValue'); const forestBoundaryValueSpan = document.getElementById('forestBoundaryValue'); const grassBoundaryValueSpan = document.getElementById('grassBoundaryValue'); const sandBoundaryValueSpan = document.getElementById('sandBoundaryValue'); const centerViewBtn = document.getElementById('centerViewBtn'); const fitViewBtn = document.getElementById('fitViewBtn'); const saveBtn = document.getElementById('saveBtn'); const loadBtn = document.getElementById('loadBtn'); const loadFileElement = document.getElementById('loadFile'); const zoomLevelSpan = document.getElementById('zoomLevel'); const coordsSpan = document.getElementById('coords'); const islandCountSpan = document.getElementById('islandCount'); const statusDiv = document.getElementById('status'); const undoBtn = document.getElementById('undoBtn'); const redoBtn = document.getElementById('redoBtn');
                 const rampHandles = { stone: handleStone, forest: handleForest, grass: handleGrass };
                 const rampValueSpans = { stone: stoneBoundaryValueSpan, forest: forestBoundaryValueSpan, grass: grassBoundaryValueSpan, sand: sandBoundaryValueSpan };

                let ctx = null;
                const requiredElements = { editorApp, canvas, canvasContainer, toolbar, toolbarCloseBtn, toolbarOpenBtn, addIslandBtn, removeIslandBtn, islandPointsInput, islandRadiusNoiseInput, radiusNoiseValueSpan, chaikinIterationsInput, iterationsValueSpan, zoomLevelSpan, coordsSpan, islandCountSpan, statusDiv, saveBtn, loadBtn, loadFileElement, undoBtn, redoBtn, islandPerlinAmpInput, perlinAmpValueSpan, islandPerlinFreqInput, perlinFreqValueSpan, centerViewBtn, fitViewBtn, layerRampContainer, layerRamp, handleStone, handleForest, handleGrass, stoneBoundaryValueSpan, forestBoundaryValueSpan, grassBoundaryValueSpan, sandBoundaryValueSpan };
                for (const [name, el] of Object.entries(requiredElements)) { if (!el) { console.error(`CRITICAL ERROR: DOM element missing: ${name}`); alert(`Initialization Error: Missing required element '${name}'.`); return; } }
                ctx = canvas.getContext('2d');
                if (!ctx) { console.error("CRITICAL ERROR: Cannot get 2D canvas context."); alert("Initialization Error: Could not get canvas context."); return; }

                // ==================================================
                // FUNCTION DEFINITIONS (Keep all existing functions as they were)
                // ==================================================
                function throttle(func, limit) { let inThrottle; return function(...args) { const context = this; if (!inThrottle) { func.apply(context, args); inThrottle = true; setTimeout(() => inThrottle = false, limit); } } }
                function deepCopy(obj) { try { return JSON.parse(JSON.stringify(obj)); } catch (e) { console.error("Deep copy failed:", e); return null; } }
                function screenToWorld(screenX, screenY) { return { x: (screenX / view.scale) + view.offsetX, y: (screenY / view.scale) + view.offsetY }; }
                function worldToScreen(worldX, worldY) { return { x: (worldX - view.offsetX) * view.scale, y: (worldY - view.offsetY) * view.scale }; }
                function getPolygonBounds(points) { if (!points || points.length === 0) return null; let minX = points[0].x, minY = points[0].y, maxX = points[0].x, maxY = points[0].y; for (let i = 1; i < points.length; i++) { minX = Math.min(minX, points[i].x); minY = Math.min(minY, points[i].y); maxX = Math.max(maxX, points[i].x); maxY = Math.max(maxY, points[i].y); } const buffer = HANDLE_SIZE / view.scale; return { minX: minX - buffer, minY: minY - buffer, maxX: maxX + buffer, maxY: maxY + buffer }; }
                function pointInPolygon(point, polygon) { if (!point || typeof point.x !== 'number' || typeof point.y !== 'number' || !polygon || polygon.length < MIN_POLYGON_POINTS) return false; let isInside = false; const n = polygon.length; for (let i = 0, j = n - 1; i < n; j = i++) { const pi = polygon[i]; const pj = polygon[j]; if (!pi || !pj || typeof pi.x !== 'number' || typeof pi.y !== 'number' || typeof pj.x !== 'number' || typeof pj.y !== 'number') continue; const intersect = ((pi.y > point.y) !== (pj.y > point.y)) && (point.x < (pj.x - pi.x) * (point.y - pi.y) / (pj.y - pi.y) + pi.x); if (intersect) isInside = !isInside; } return isInside; }
                function calculateCentroid(points) { let cx=0, cy=0; if (!points || points.length === 0) return {x:NaN, y:NaN}; points.forEach(p => { cx += p.x; cy += p.y; }); const len = points.length; if (len === 0 || isNaN(cx) || isNaN(cy)) return {x:NaN, y:NaN}; return { x: cx / len, y: cy / len }; }
                function doBoxesIntersect(boxA, boxB) { if (!boxA || !boxB || isNaN(boxA.minX) || isNaN(boxB.minX)) return false; return boxA.minX < boxB.maxX && boxA.maxX > boxB.minX && boxA.minY < boxB.maxY && boxA.maxY > boxB.minY; }
                function drawPolygon(targetCtx, points, isClosed) { if (!points || points.length < 2) return; targetCtx.beginPath(); if(isNaN(points[0]?.x) || isNaN(points[0]?.y)) {console.warn("DrawPolygon start NaN"); return;} targetCtx.moveTo(points[0].x, points[0].y); for (let i = 1; i < points.length; i++) { if(isNaN(points[i]?.x) || isNaN(points[i]?.y)) {console.warn("DrawPolygon mid NaN at index", i); continue;} targetCtx.lineTo(points[i].x, points[i].y); } if (isClosed) { targetCtx.closePath(); } }
                function chaikinSmooth(points, isClosed, iterations) { const minInputPoints = isClosed ? MIN_POLYGON_POINTS : 2; let currentPoints = points; if (!currentPoints || currentPoints.length < minInputPoints) return currentPoints; for (let iter = 0; iter < iterations; iter++) { if (!currentPoints || currentPoints.length < minInputPoints) break; const newPoints = []; const n = currentPoints.length; const loopLimit = isClosed ? n : n - 1; for (let i = 0; i < loopLimit; i++) { const p0 = currentPoints[i]; const p1 = currentPoints[(i + 1) % n]; if (!p0 || !p1 || isNaN(p0.x) || isNaN(p0.y) || isNaN(p1.x) || isNaN(p1.y)) { console.warn(`Chaikin skipping invalid points at index ${i}`); continue; } const qx = 0.75 * p0.x + 0.25 * p1.x; const qy = 0.75 * p0.y + 0.25 * p1.y; const rx = 0.25 * p0.x + 0.75 * p1.x; const ry = 0.25 * p0.y + 0.75 * p1.y; newPoints.push({ x: qx, y: qy }); newPoints.push({ x: rx, y: ry }); } if (newPoints.length < minInputPoints && currentPoints.length >= minInputPoints) { console.warn("Chaikin smoothing resulted in too few points, returning previous iteration."); return currentPoints; } currentPoints = newPoints; } return currentPoints; }
                function scaleLayerPoints(points, center, scaleFactor) { if (!points || !center || isNaN(center.x) || isNaN(scaleFactor)) return points; return points.map(p => scalePoint(p, center, scaleFactor)); }
                function rotatePoint(point, center, angleRad) { const cosA = Math.cos(angleRad); const sinA = Math.sin(angleRad); const dx = point.x - center.x; const dy = point.y - center.y; return { x: center.x + dx * cosA - dy * sinA, y: center.y + dx * sinA + dy * cosA }; }
                function scalePoint(point, center, scaleFactor) { const dx = point.x - center.x; const dy = point.y - center.y; return { x: center.x + dx * scaleFactor, y: center.y + dy * scaleFactor }; }
                function generateIslandShape(params, centerPos = null) { if (typeof window.noise === 'undefined' || typeof window.noise.perlin2 !== 'function') { console.error("Cannot generate island: noise library not available."); return null; } if (!params || params.numPoints < MIN_POLYGON_POINTS) { console.error("Cannot generate island: Insufficient points in params."); return null; } try { const centerX = centerPos?.x ?? (mapData.width / 2 + (Math.random() - 0.5) * mapData.width * 0.8); const centerY = centerPos?.y ?? (mapData.height / 2 + (Math.random() - 0.5) * mapData.height * 0.8); if (isNaN(centerX) || isNaN(centerY)) { console.error("GenShape: Invalid center position calculated."); return null; } const baseRadiusX = mapData.width * (0.05 + Math.random() * 0.06); const baseRadiusY = mapData.height * (0.05 + Math.random() * 0.06); const baseShapePoints = []; const angleStep = (Math.PI * 2) / params.numPoints; for (let i = 0; i < params.numPoints; i++) { const angle = i * angleStep; const noiseX = Math.cos(angle) * params.perlinFreq; const noiseY = Math.sin(angle) * params.perlinFreq; const perlinValue = window.noise.perlin2(noiseX, noiseY); const perlinFactor = 1.0 + perlinValue * params.perlinAmp; const randomFactor = 1.0 + (Math.random() - 0.5) * 2 * params.radiusNoise; const noisyRadiusX = baseRadiusX * perlinFactor * randomFactor; const noisyRadiusY = baseRadiusY * perlinFactor * randomFactor; const x = centerX + Math.cos(angle) * noisyRadiusX; const y = centerY + Math.sin(angle) * noisyRadiusY; if (isNaN(x) || isNaN(y)) { console.error("GenShape: NaN encountered during base point calculation for point", i); return null;} baseShapePoints.push({ x: Math.round(x), y: Math.round(y) }); } const islandCenter = calculateCentroid(baseShapePoints); if (isNaN(islandCenter.x)) { console.error("GenShape: Invalid island centroid calculated from base points."); return null; } const grassLine = (params.grassBoundary ?? DEFAULT_LAYER_BOUNDARIES.grass) / 100.0; const forestLine = (params.forestBoundary ?? DEFAULT_LAYER_BOUNDARIES.forest) / 100.0; const stoneLine = (params.stoneBoundary ?? DEFAULT_LAYER_BOUNDARIES.stone) / 100.0; const boundaryDefs = [ { type: 'sand', scaleFactor: 1.0 }, { type: 'grass', scaleFactor: Math.max(0, Math.min(1, grassLine)) }, { type: 'forest', scaleFactor: Math.max(0, Math.min(1, forestLine)) }, { type: 'stone', scaleFactor: Math.max(0, Math.min(1, stoneLine)) } ]; const generatedLayers = []; for (const boundaryDef of boundaryDefs) { const scaleFactor = boundaryDef.scaleFactor; if (isNaN(scaleFactor) || (scaleFactor < 0.001 && boundaryDef.type !== 'stone') ) continue; let scaledPoints = scaleLayerPoints(baseShapePoints, islandCenter, scaleFactor); let smoothedPoints = chaikinSmooth(scaledPoints, true, params.iterations); if (!smoothedPoints || smoothedPoints.length < MIN_POLYGON_POINTS) { console.warn(`Layer generation/smoothing failed for ${boundaryDef.type} (scale: ${scaleFactor}). Skipping layer.`); continue; } generatedLayers.push({ type: boundaryDef.type, color: LAYER_COLORS[boundaryDef.type], points: smoothedPoints.map(p => ({...p})) }); } generatedLayers.sort((a, b) => RENDER_ORDER.indexOf(a.type) - RENDER_ORDER.indexOf(b.type)); if (generatedLayers.length === 0) { console.error("GenShape: Failed to generate any valid layers."); return null; } return { layers: generatedLayers, center: islandCenter }; } catch (genError) { console.error("Error during generateIslandShape:", genError); return null; } }
                function resizeCanvas(forceRender = true) { const cw = canvasContainer.clientWidth; const ch = canvasContainer.clientHeight; if (canvas.width !== cw || canvas.height !== ch) { canvas.width = cw; canvas.height = ch; console.log(`Canvas resized: ${cw}x${ch}`); if (forceRender) requestAnimationFrame(renderMap); return true; } return false; }
                function centerViewOn(worldX, worldY) { if (!canvas || isNaN(worldX) || isNaN(worldY)) return; view.offsetX = worldX - (canvas.width / 2 / view.scale); view.offsetY = worldY - (canvas.height / 2 / view.scale); requestAnimationFrame(renderMap); }
                function resetViewToMapCenter() { view.scale = 1.0; view.offsetX = (mapData.width / 2) - (canvas.width > 0 ? canvas.width / 2 : 0); view.offsetY = (mapData.height / 2) - (canvas.height > 0 ? canvas.height / 2 : 0); updateZoomDisplay(); requestAnimationFrame(renderMap); console.log("View Reset to Map Center", view); }
                function updateZoomDisplay() { if (zoomLevelSpan) zoomLevelSpan.textContent = `${Math.round(view.scale * 100)}%`; }
                function updateCoordsDisplay(screenX, screenY) { if (coordsSpan) { const worldPos = screenToWorld(screenX, screenY); coordsSpan.textContent = `(${Math.round(worldPos.x)}, ${Math.round(worldPos.y)})`; } }
                function getViewportBoundsWorld() { const topLeft = screenToWorld(0, 0); const bottomRight = screenToWorld(canvas.width, canvas.height); return { minX: topLeft.x, minY: topLeft.y, maxX: bottomRight.x, maxY: bottomRight.y }; }
                function fitViewToIslands() { if (mapData.islands.length === 0) { resetViewToMapCenter(); return; } let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; let foundValidBounds = false; mapData.islands.forEach(island => { const outerLayer = island.layers?.find(l => l.type === 'sand'); if (outerLayer?.points) { const bounds = getPolygonBounds(outerLayer.points); if (bounds && !isNaN(bounds.minX)) { minX = Math.min(minX, bounds.minX); minY = Math.min(minY, bounds.minY); maxX = Math.max(maxX, bounds.maxX); maxY = Math.max(maxY, bounds.maxY); foundValidBounds = true; } } }); if (!foundValidBounds) { console.warn("Fit View: No valid outer island bounds found."); resetViewToMapCenter(); return; } const worldWidth = maxX - minX; const worldHeight = maxY - minY; if (worldWidth <= 0 || worldHeight <= 0) { console.warn("Fit View: Invalid world dimensions calculated."); resetViewToMapCenter(); return; } const scaleX = canvas.width / (worldWidth * FIT_VIEW_PADDING_FACTOR); const scaleY = canvas.height / (worldHeight * FIT_VIEW_PADDING_FACTOR); let newScale = Math.min(scaleX, scaleY); newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newScale)); view.scale = newScale; updateZoomDisplay(); const centerX = minX + worldWidth / 2; const centerY = minY + worldHeight / 2; centerViewOn(centerX, centerY); console.log(`Fit View executed. New scale: ${view.scale.toFixed(2)}`); }
                function renderMap() { if (!ctx || !canvas) return; try { ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.fillStyle = OCEAN_COLOR_HEX; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.scale(view.scale, view.scale); ctx.translate(-view.offsetX, -view.offsetY); const viewportBounds = getViewportBoundsWorld(); let selectedIslandData = null; const selectedIndex = mapData.islands.findIndex(isl => isl.id === selectedIslandId); mapData.islands.forEach((island, index) => { if (index === selectedIndex) return; const outerLayer = island.layers?.find(l => l.type === 'sand'); if (outerLayer?.points) { const islandBounds = getPolygonBounds(outerLayer.points); if (islandBounds && doBoxesIntersect(viewportBounds, islandBounds)) { drawSingleIsland(island, false); } else if (!islandBounds) { console.warn(`Island ${island.id} missing bounds, drawing anyway.`); drawSingleIsland(island, false); } } }); if (selectedIndex > -1) { selectedIslandData = mapData.islands[selectedIndex]; const outerLayer = selectedIslandData.layers?.find(l => l.type === 'sand'); if (outerLayer?.points) { const islandBounds = getPolygonBounds(outerLayer.points); if (islandBounds && doBoxesIntersect(viewportBounds, islandBounds)) { drawSingleIsland(selectedIslandData, true); } else if (!islandBounds) { drawSingleIsland(selectedIslandData, true); } else { selectedIslandData = null; } } else { selectedIslandData = null; } } if (isPlacingIsland && previewIslandData?.layers?.[0]?.points) { ctx.fillStyle = PREVIEW_FILL_COLOR; ctx.strokeStyle = isPreviewColliding ? PREVIEW_COLLISION_OUTLINE_COLOR : PREVIEW_OUTLINE_COLOR; ctx.lineWidth = DEFAULT_OUTLINE_WIDTH / view.scale; ctx.setLineDash([5 / view.scale, 3 / view.scale]); drawPolygon(ctx, previewIslandData.layers[0].points, true); ctx.fill(); ctx.stroke(); ctx.setLineDash([]); } ctx.restore(); if (selectedIslandData) { drawHandles(selectedIslandData); } } catch (renderError) { console.error("Error during renderMap:", renderError); try { ctx.restore(); } catch(e){} } }
                function drawSingleIsland(island, isSelected) { if (!island?.layers || island.layers.length === 0) return; RENDER_ORDER.forEach(layerType => { const layer = island.layers.find(l => l.type === layerType); if (layer && layer.points && layer.points.length >= MIN_POLYGON_POINTS) { ctx.fillStyle = layer.color || '#FF00FF'; drawPolygon(ctx, layer.points, true); ctx.fill(); if (layer.type === 'sand') { ctx.strokeStyle = isSelected ? SELECTED_OUTLINE_COLOR : DEFAULT_OUTLINE_COLOR; ctx.lineWidth = (isSelected ? DEFAULT_OUTLINE_WIDTH * SELECTED_OUTLINE_WIDTH_FACTOR : DEFAULT_OUTLINE_WIDTH) / view.scale; ctx.stroke(); } } else if(layer) { console.warn(`Skipping drawing layer ${layer.type} for island ${island.id} (invalid points?).`); } }); }
                function getHandlePositions(island) { if (!island?.layers?.length || !island.center || isNaN(island.center.x)) return null; const outerLayerPoints = island.layers.find(l => l.type === 'sand')?.points; if (!outerLayerPoints) return null; const bounds = getPolygonBounds(outerLayerPoints); if(!bounds || isNaN(bounds.minX)) return null; const rotateHandleDist = ROTATE_HANDLE_OFFSET / view.scale; const handles = { 'scale-tl': { x: bounds.minX, y: bounds.minY }, 'scale-tr': { x: bounds.maxX, y: bounds.minY }, 'scale-bl': { x: bounds.minX, y: bounds.maxY }, 'scale-br': { x: bounds.maxX, y: bounds.maxY }, 'rotate':   { x: island.center.x, y: island.center.y - (bounds.maxY - bounds.minY) / 2 - rotateHandleDist } }; return handles; }
                function drawHandles(island) { const handlePositionsWorld = getHandlePositions(island); if (!handlePositionsWorld) return; const handleSizeScreen = HANDLE_SIZE; ctx.save(); ctx.setTransform(1, 0, 0, 1, 0, 0); Object.entries(handlePositionsWorld).forEach(([type, worldPos]) => { if (isNaN(worldPos?.x) || isNaN(worldPos?.y)) return; const screenPos = worldToScreen(worldPos.x, worldPos.y); const isRotate = type === 'rotate'; ctx.beginPath(); if (isRotate) { ctx.fillStyle = ROTATE_HANDLE_COLOR; ctx.arc(screenPos.x, screenPos.y, handleSizeScreen / 1.5, 0, Math.PI * 2); } else { ctx.fillStyle = HANDLE_COLOR; ctx.rect(screenPos.x - handleSizeScreen / 2, screenPos.y - handleSizeScreen / 2, handleSizeScreen, handleSizeScreen); } ctx.strokeStyle = HANDLE_STROKE_COLOR; ctx.lineWidth = 1; ctx.fill(); ctx.stroke(); }); ctx.restore(); }
                function updateUndoRedoButtons() { undoBtn.disabled = undoStack.length === 0; redoBtn.disabled = redoStack.length === 0; }
                function saveState(actionName = "Unknown Action") { if (historyLocked) return; if (redoStack.length > 0) { console.log("Clearing redo stack due to new action."); redoStack = []; } const stateSnapshot = deepCopy(mapData.islands); if (!stateSnapshot) { console.error("Failed to create state snapshot for undo."); return; } undoStack.push({ name: actionName, state: stateSnapshot }); console.log(`Saved state: ${actionName} (Undo: ${undoStack.length})`); if (undoStack.length > UNDO_STACK_LIMIT) { undoStack.shift(); } updateUndoRedoButtons(); }
                function undo() { if (undoStack.length === 0) return; historyLocked = true; try { const currentStateSnapshot = deepCopy(mapData.islands); if(currentStateSnapshot) { redoStack.push({ name: "State Before Undo", state: currentStateSnapshot }); } else { console.error("Failed to snapshot current state before undo."); } const lastStateEntry = undoStack.pop(); console.log(`Undoing: ${lastStateEntry.name}`); mapData.islands = deepCopy(lastStateEntry.state); if (!mapData.islands) { console.error("CRITICAL: Failed to restore state from undo stack. Resetting islands."); mapData.islands = []; } islandCountSpan.textContent = mapData.islands.length; if (selectedIslandId !== null && !mapData.islands.some(isl => isl.id === selectedIslandId)) { selectedIslandId = null; } updateSelectionState(); } catch(e) { console.error("Error during undo operation:", e); } finally { historyLocked = false; updateUndoRedoButtons(); requestAnimationFrame(renderMap); } }
                function redo() { if (redoStack.length === 0) return; historyLocked = true; try { const currentStateSnapshot = deepCopy(mapData.islands); if (currentStateSnapshot) { undoStack.push({ name: "State Before Redo", state: currentStateSnapshot }); if (undoStack.length > UNDO_STACK_LIMIT) { undoStack.shift(); } } else { console.error("Failed to snapshot current state before redo."); } const nextStateEntry = redoStack.pop(); console.log(`Redoing: ${nextStateEntry.name}`); mapData.islands = deepCopy(nextStateEntry.state); if (!mapData.islands) { console.error("CRITICAL: Failed to restore state from redo stack. Resetting islands."); mapData.islands = []; } islandCountSpan.textContent = mapData.islands.length; if (selectedIslandId !== null && !mapData.islands.some(isl => isl.id === selectedIslandId)) { selectedIslandId = null; } updateSelectionState(); } catch(e) { console.error("Error during redo operation:", e); } finally { historyLocked = false; updateUndoRedoButtons(); requestAnimationFrame(renderMap); } }
                function saveMap() { try { saveState("Before Save"); if (selectedIslandId !== null) { const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (island) { island.params = getCurrentEditorParams(); } } const mapFileContent = { version: 1, width: mapData.width, height: mapData.height, islands: mapData.islands, nextIslandId: nextIslandId }; const mapJSON = JSON.stringify(mapFileContent, null, 2); const blob = new Blob([mapJSON], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `vector-island-map-${Date.now()}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); console.log("Map state saved successfully."); } catch (e) { console.error("Error saving map state:", e); alert("Error saving map state. See console for details."); } }
                function triggerLoadMap() { loadFileElement.click(); }
                function loadMap(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const loadedData = JSON.parse(e.target.result); if (!loadedData || typeof loadedData !== 'object') throw new Error("Invalid file content."); if (!Array.isArray(loadedData.islands)) throw new Error("Invalid map format: 'islands' array missing or not an array."); const processedIslands = []; loadedData.islands.forEach((island, index) => { if (!island || typeof island !== 'object') throw new Error(`Invalid data for island at index ${index}.`); if (typeof island.id !== 'number') throw new Error(`Missing or invalid 'id' for island at index ${index}.`); if (!island.center || typeof island.center.x !== 'number' || typeof island.center.y !== 'number') throw new Error(`Missing or invalid 'center' for island ${island.id}.`); if (!Array.isArray(island.layers)) throw new Error(`Missing or invalid 'layers' array for island ${island.id}.`); island.params = island.params || {}; island.params.grassBoundary = island.params.grassBoundary ?? DEFAULT_LAYER_BOUNDARIES.grass; island.params.forestBoundary = island.params.forestBoundary ?? DEFAULT_LAYER_BOUNDARIES.forest; island.params.stoneBoundary = island.params.stoneBoundary ?? DEFAULT_LAYER_BOUNDARIES.stone; island.params.numPoints = island.params.numPoints ?? 16; island.params.radiusNoise = island.params.radiusNoise ?? 0.2; island.params.perlinAmp = island.params.perlinAmp ?? 0.5; island.params.perlinFreq = island.params.perlinFreq ?? 1.5; island.params.iterations = island.params.iterations ?? 4; delete island.params.grassLine; processedIslands.push(island); }); saveState("Before Load"); mapData.islands = processedIslands; mapData.width = loadedData.width || MAP_WIDTH; mapData.height = loadedData.height || MAP_HEIGHT; nextIslandId = loadedData.nextIslandId || (mapData.islands.length > 0 ? Math.max(0, ...mapData.islands.map(isl => isl.id)) + 1 : 0); selectedIslandId = null; islandCountSpan.textContent = mapData.islands.length; updateSelectionState(); resetViewToMapCenter(); console.log("Map loaded successfully."); alert("Map loaded successfully."); } catch (err) { console.error("Error loading or parsing map file:", err); alert(`Error loading map: ${err.message}\nCheck console for details.`); saveState("Load Failed"); } finally { event.target.value = null; } }; reader.onerror = (e) => { console.error("Error reading file:", e); alert("Error reading map file."); event.target.value = null; }; reader.readAsText(file); }
                function getCurrentEditorParams() { const boundaries = getBoundariesFromRamp(); return { numPoints: parseInt(islandPointsInput.value, 10) || 16, radiusNoise: parseFloat(islandRadiusNoiseInput.value) || 0, perlinAmp: parseFloat(islandPerlinAmpInput.value) || 0, perlinFreq: parseFloat(islandPerlinFreqInput.value) || 1, iterations: parseInt(chaikinIterationsInput.value, 10) || 0, grassBoundary: boundaries.grass, forestBoundary: boundaries.forest, stoneBoundary: boundaries.stone, }; }
                function generatePreviewShape(worldPos) { const params = getCurrentEditorParams(); const shapeData = generateIslandShape(params, worldPos); if (shapeData && shapeData.layers && shapeData.layers.length > 0) { previewIslandData = { layers: shapeData.layers, center: shapeData.center, params: params }; checkPreviewCollision(); } else { previewIslandData = { layers: null, center: null, params: null }; isPreviewColliding = false; console.warn("Failed to generate preview shape."); } requestAnimationFrame(renderMap); }
                function startIslandPlacement() { if (isPlacingIsland) return; isPlacingIsland = true; selectedIslandId = null; updateSelectionState(); addIslandBtn.classList.add('active'); canvasContainer.style.cursor = 'crosshair'; const viewCenterX = view.offsetX + (canvas.width / 2 / view.scale); const viewCenterY = view.offsetY + (canvas.height / 2 / view.scale); generatePreviewShape({ x: viewCenterX, y: viewCenterY }); }
                function updatePlacementPreview(worldPos) { if (!isPlacingIsland || !previewIslandData?.layers || !previewIslandData.center || isNaN(worldPos?.x)) return; const deltaX = worldPos.x - previewIslandData.center.x; const deltaY = worldPos.y - previewIslandData.center.y; if (isNaN(deltaX) || isNaN(deltaY) || (Math.abs(deltaX) < 0.1 && Math.abs(deltaY) < 0.1)) return; previewIslandData.layers.forEach(layer => { layer.points.forEach(p => { p.x += deltaX; p.y += deltaY; }); }); previewIslandData.center.x += deltaX; previewIslandData.center.y += deltaY; checkPreviewCollision(); requestAnimationFrame(renderMap); }
                function checkPreviewCollision() { if (!previewIslandData?.layers?.[0]?.points) { isPreviewColliding = false; return; } const previewBounds = getPolygonBounds(previewIslandData.layers[0].points); if(!previewBounds) { isPreviewColliding = false; return; } isPreviewColliding = mapData.islands.some(island => { const islandOuterLayer = island.layers?.find(l=>l.type==='sand')?.points; if (!islandOuterLayer) return false; const islandBounds = getPolygonBounds(islandOuterLayer); return islandBounds && doBoxesIntersect(previewBounds, islandBounds); }); }
                function finalizePlacement() { if (!isPlacingIsland || !previewIslandData?.layers || previewIslandData.layers.length === 0) { cancelPlacement(); return; } if (isPreviewColliding) { console.log("Placement blocked by collision."); alert("Cannot place island here, it overlaps another island."); return; } const finalCenter = previewIslandData.center; if(isNaN(finalCenter?.x)){ console.error("Invalid center for final placement."); cancelPlacement(); return; } saveState("Add Island"); const newIsland = { id: nextIslandId++, layers: deepCopy(previewIslandData.layers), center: finalCenter, params: { ...previewIslandData.params } }; mapData.islands.push(newIsland); islandCountSpan.textContent = mapData.islands.length; cancelPlacement(false); updateSelectionState(); requestAnimationFrame(renderMap); }
                function cancelPlacement(clearPreview = true) { isPlacingIsland = false; if (clearPreview) previewIslandData = { layers: null, center: null, params: null }; addIslandBtn.classList.remove('active'); canvasContainer.style.cursor = 'grab'; requestAnimationFrame(renderMap); }
                function regenerateSelectedIslandInternal() { if (selectedIslandId === null) return; const islandIndex = mapData.islands.findIndex(isl => isl.id === selectedIslandId); if (islandIndex === -1) { console.error("Regenerate failed: Selected island not found."); return; } const island = mapData.islands[islandIndex]; if (!island || !island.layers?.length || !island.center) { console.error("Cannot regenerate: Invalid selected island data."); return; } const currentSandLayer = island.layers.find(l => l.type === 'sand'); let currentEffectiveRadius = 0; if (currentSandLayer?.points && !isNaN(island.center.x)) { let currentMaxDistSq = 0; currentSandLayer.points.forEach(p => { const dx = p.x - island.center.x; const dy = p.y - island.center.y; currentMaxDistSq = Math.max(currentMaxDistSq, dx*dx + dy*dy); }); currentEffectiveRadius = Math.sqrt(currentMaxDistSq); } const hasValidCurrentRadius = !isNaN(currentEffectiveRadius) && currentEffectiveRadius > 0; if (!hasValidCurrentRadius) { console.warn("Could not determine current radius for scaling during regeneration."); } const currentParams = getCurrentEditorParams(); const newShapeData = generateIslandShape(currentParams, island.center); if (!newShapeData || !newShapeData.layers || newShapeData.layers.length === 0) { console.error("Regeneration failed during new shape generation."); return; } const newSandLayer = newShapeData.layers.find(l => l.type === 'sand'); let scaleFactor = 1.0; if (hasValidCurrentRadius && newSandLayer?.points && !isNaN(newShapeData.center.x)) { let newBaseMaxDistSq = 0; newSandLayer.points.forEach(p => { const dx = p.x - newShapeData.center.x; const dy = p.y - newShapeData.center.y; newBaseMaxDistSq = Math.max(newBaseMaxDistSq, dx*dx + dy*dy); }); const newShapeBaseRadius = Math.sqrt(newBaseMaxDistSq); const hasValidNewBaseRadius = !isNaN(newShapeBaseRadius) && newShapeBaseRadius > 0; if (hasValidNewBaseRadius) { scaleFactor = currentEffectiveRadius / newShapeBaseRadius; } else { console.warn("Could not determine new base radius for scaling."); } } if (Math.abs(scaleFactor - 1.0) > 0.001) { console.log(`Regenerating with scale factor: ${scaleFactor.toFixed(3)}`); newShapeData.layers.forEach(layer => { layer.points = layer.points.map(p => scalePoint(p, newShapeData.center, scaleFactor)); }); const finalSandPoints = newShapeData.layers.find(l => l.type === 'sand')?.points; island.center = calculateCentroid(finalSandPoints || []); } else { island.center = newShapeData.center; } island.layers = newShapeData.layers; island.params = currentParams; mapData.islands[islandIndex] = island; requestAnimationFrame(renderMap); }
                const throttledRegenerate = throttle(() => { saveState("Regenerate Island Shape"); regenerateSelectedIslandInternal(); }, PARAM_UPDATE_THROTTLE_MS);
                 function updateIslandLayersOnly() { if (selectedIslandId === null) return; const islandIndex = mapData.islands.findIndex(isl => isl.id === selectedIslandId); if (islandIndex === -1) { console.error("Layer update failed: Selected island not found."); return; } const island = mapData.islands[islandIndex]; if (!island || !island.layers?.length || !island.center) { console.error("Cannot update layers: Invalid selected island data."); return; } const sandLayer = island.layers.find(l => l.type === 'sand'); if (!sandLayer?.points || sandLayer.points.length < MIN_POLYGON_POINTS) { console.error("Cannot update layers: Valid Sand layer not found."); return; } const sandPoints = sandLayer.points; const islandCenter = island.center; const currentParams = getCurrentEditorParams(); const newInnerLayers = []; const grassLine = (currentParams.grassBoundary ?? DEFAULT_LAYER_BOUNDARIES.grass) / 100.0; const forestLine = (currentParams.forestBoundary ?? DEFAULT_LAYER_BOUNDARIES.forest) / 100.0; const stoneLine = (currentParams.stoneBoundary ?? DEFAULT_LAYER_BOUNDARIES.stone) / 100.0; const boundaryDefs = [ { type: 'grass', scaleFactor: Math.max(0, Math.min(1, grassLine)) }, { type: 'forest', scaleFactor: Math.max(0, Math.min(1, forestLine)) }, { type: 'stone', scaleFactor: Math.max(0, Math.min(1, stoneLine)) } ]; for (const boundaryDef of boundaryDefs) { const scaleFactor = boundaryDef.scaleFactor; if (isNaN(scaleFactor) || (scaleFactor < 0.001 && boundaryDef.type !== 'stone')) continue; let scaledPoints = scaleLayerPoints(sandPoints, islandCenter, scaleFactor); let smoothedPoints = chaikinSmooth(scaledPoints, true, currentParams.iterations); if (!smoothedPoints || smoothedPoints.length < MIN_POLYGON_POINTS) { console.warn(`Layer boundary update failed for ${boundaryDef.type} (scale: ${scaleFactor}). Skipping layer.`); continue;} newInnerLayers.push({ type: boundaryDef.type, color: LAYER_COLORS[boundaryDef.type], points: smoothedPoints.map(p => ({...p})) }); } island.layers = [ sandLayer, ...newInnerLayers ].sort((a, b) => RENDER_ORDER.indexOf(a.type) - RENDER_ORDER.indexOf(b.type)); island.params = currentParams; mapData.islands[islandIndex] = island; requestAnimationFrame(renderMap); }
                 const throttledUpdateLayers = throttle(() => { updateIslandLayersOnly(); }, PARAM_UPDATE_THROTTLE_MS / 2);
                 function updateSelectionState() { const isIslandSelected = selectedIslandId !== null; removeIslandBtn.disabled = !isIslandSelected; let params = null; if (isIslandSelected) { const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (!island?.params) { console.warn("Selected island missing params object. Using defaults."); params = getCurrentEditorParams(); } else { params = island.params; } } else { params = getCurrentEditorParams(); } islandPointsInput.value = params?.numPoints ?? 16; islandRadiusNoiseInput.value = params?.radiusNoise ?? 0.2; radiusNoiseValueSpan.textContent = parseFloat(islandRadiusNoiseInput.value).toFixed(2); islandPerlinAmpInput.value = params?.perlinAmp ?? 0.5; perlinAmpValueSpan.textContent = parseFloat(islandPerlinAmpInput.value).toFixed(2); islandPerlinFreqInput.value = params?.perlinFreq ?? 1.5; perlinFreqValueSpan.textContent = parseFloat(islandPerlinFreqInput.value).toFixed(1); chaikinIterationsInput.value = params?.iterations ?? 4; iterationsValueSpan.textContent = chaikinIterationsInput.value; setRampHandles(params); requestAnimationFrame(renderMap); }
                 function setRampHandles(params) { const grassB = params?.grassBoundary ?? DEFAULT_LAYER_BOUNDARIES.grass; const forestB = params?.forestBoundary ?? DEFAULT_LAYER_BOUNDARIES.forest; const stoneB = params?.stoneBoundary ?? DEFAULT_LAYER_BOUNDARIES.stone; if (rampWidth > 0) { handleGrass.style.left = `${(grassB / 100) * rampWidth - (handleGrass.offsetWidth / 2)}px`; handleForest.style.left = `${(forestB / 100) * rampWidth - (handleForest.offsetWidth / 2)}px`; handleStone.style.left = `${(stoneB / 100) * rampWidth - (handleStone.offsetWidth / 2)}px`; } else { console.warn("setRampHandles called before rampWidth was calculated. Using percentage fallback."); handleGrass.style.left = `${grassB}%`; handleForest.style.left = `${forestB}%`; handleStone.style.left = `${stoneB}%`; } rampValueSpans.grass.textContent = `${Math.round(grassB)}%`; rampValueSpans.forest.textContent = `${Math.round(forestB)}%`; rampValueSpans.stone.textContent = `${Math.round(stoneB)}%`; rampValueSpans.sand.textContent = `${Math.max(0, 100 - Math.round(grassB))}%`; }
                 function getBoundariesFromRamp() { if (rampWidth <= 0) { console.warn("getBoundariesFromRamp called with invalid rampWidth. Returning defaults."); return { ...DEFAULT_LAYER_BOUNDARIES }; } const grassPercent = (parseFloat(handleGrass.style.left) + handleGrass.offsetWidth / 2) / rampWidth * 100; const forestPercent = (parseFloat(handleForest.style.left) + handleForest.offsetWidth / 2) / rampWidth * 100; const stonePercent = (parseFloat(handleStone.style.left) + handleStone.offsetWidth / 2) / rampWidth * 100; return { grass: Math.round(Math.max(0, Math.min(100, grassPercent))), forest: Math.round(Math.max(0, Math.min(100, forestPercent))), stone: Math.round(Math.max(0, Math.min(100, stonePercent))), }; }
                function selectIslandAt(worldPoint) { let foundIslandId = null; for (let i = mapData.islands.length - 1; i >= 0; i--) { const island = mapData.islands[i]; const outerLayer = island?.layers?.find(l => l.type === 'sand')?.points; if (outerLayer && pointInPolygon(worldPoint, outerLayer)) { foundIslandId = island.id; break; } } if (selectedIslandId !== foundIslandId) { selectedIslandId = foundIslandId; updateSelectionState(); } return foundIslandId !== null; }
                function deleteSelectedIsland() { if (selectedIslandId === null) return; saveState("Delete Island"); const index = mapData.islands.findIndex(isl => isl.id === selectedIslandId); if (index > -1) { mapData.islands.splice(index, 1); selectedIslandId = null; islandCountSpan.textContent = mapData.islands.length; updateSelectionState(); } else { console.warn("Delete failed: Selected Island ID not found in mapData."); selectedIslandId = null; updateSelectionState(); } }
                function moveIsland(island, worldDeltaX, worldDeltaY) { if (!island?.layers || isNaN(worldDeltaX) || isNaN(worldDeltaY)) return; island.layers.forEach(layer => { layer.points.forEach(p => { p.x += worldDeltaX; p.y += worldDeltaY; }); }); island.center.x += worldDeltaX; island.center.y += worldDeltaY; }
                function hitTestHandles(worldPoint) { if (selectedIslandId === null || isNaN(worldPoint?.x)) return null; const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (!island) return null; const handlePositionsWorld = getHandlePositions(island); if (!handlePositionsWorld) return null; const handleHitRadiusWorldSq = Math.pow((HANDLE_SIZE / 2) / view.scale, 2); for (const [type, handleWorldPos] of Object.entries(handlePositionsWorld)) { if(isNaN(handleWorldPos?.x) || isNaN(handleWorldPos?.y)) continue; const dx = worldPoint.x - handleWorldPos.x; const dy = worldPoint.y - handleWorldPos.y; const distSq = dx * dx + dy * dy; if (distSq < handleHitRadiusWorldSq) { return type; } } return null; }
                function startHandleDrag(handleType, worldPos) { const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (!island || !island.center || !island.layers || isNaN(island.center.x) || isNaN(worldPos?.x)) return; activeHandle = handleType; dragStartIslandLayers = deepCopy(island.layers); if (!dragStartIslandLayers) { console.error("Failed to copy layers for handle drag start."); activeHandle = null; return; } dragStartIslandCenter = { ...island.center }; const dx = worldPos.x - dragStartIslandCenter.x; const dy = worldPos.y - dragStartIslandCenter.y; dragStartHandleInfo.angle = Math.atan2(dy, dx); dragStartHandleInfo.dist = Math.sqrt(dx*dx + dy*dy); if (isNaN(dragStartHandleInfo.angle) || isNaN(dragStartHandleInfo.dist)) { console.warn("NaN in startHandleDrag calculation"); activeHandle = null; return; } isMovingIsland = false; isPanning = false; canvasContainer.style.cursor = 'crosshair'; }
                function updateHandleDrag(worldPos) { if (!activeHandle || !dragStartIslandLayers || !dragStartIslandCenter || isNaN(worldPos?.x)) return; const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (!island) return; const dx = worldPos.x - dragStartIslandCenter.x; const dy = worldPos.y - dragStartIslandCenter.y; const currentAngle = Math.atan2(dy, dx); const currentDist = Math.sqrt(dx*dx + dy*dy); if (isNaN(currentAngle) || isNaN(currentDist)) { console.warn("NaN in updateHandleDrag calculation"); return; } let transformationApplied = false; if (activeHandle === 'rotate') { const angleDelta = currentAngle - dragStartHandleInfo.angle; if(isNaN(angleDelta)) return; island.layers.forEach((layer, index) => { const startLayer = dragStartIslandLayers[index]; if (startLayer?.points) { layer.points = startLayer.points.map(p => rotatePoint(p, dragStartIslandCenter, angleDelta)); } }); transformationApplied = true; } else if (activeHandle.startsWith('scale')) { if (dragStartHandleInfo.dist < 1) return; const scaleFactor = currentDist / dragStartHandleInfo.dist; if (scaleFactor < 0.05 || scaleFactor > 20 || isNaN(scaleFactor)) return; island.layers.forEach((layer, index) => { const startLayer = dragStartIslandLayers[index]; if (startLayer?.points) { layer.points = startLayer.points.map(p => scalePoint(p, dragStartIslandCenter, scaleFactor)); } }); transformationApplied = true; } if(transformationApplied) { const outerLayerPoints = island.layers.find(l=>l.type==='sand')?.points; if(outerLayerPoints){ island.center = calculateCentroid(outerLayerPoints); } else { console.warn("Could not find outer layer points to recalculate center after transform."); } requestAnimationFrame(renderMap); } }
                function endHandleDrag() { if (!activeHandle) return; saveState(`Transform Island (${activeHandle})`); activeHandle = null; const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (island) { const outerLayerPoints = island.layers.find(l=>l.type==='sand')?.points; if(outerLayerPoints){ island.center = calculateCentroid(outerLayerPoints); } requestAnimationFrame(renderMap); } dragStartIslandLayers = null; dragStartIslandCenter = null; canvasContainer.style.cursor = selectedIslandId !== null ? 'pointer' : 'grab'; }
                function startRampDrag(event) { if (!event.target.classList.contains('ramp-handle')) return; isDraggingRampHandle = true; draggedRampHandle = event.target; rampDragStartX = event.clientX; rampWidth = layerRamp.offsetWidth; rampLeft = layerRamp.getBoundingClientRect().left; if (rampWidth <= 0) { console.error("Cannot start ramp drag: ramp width is zero."); isDraggingRampHandle = false; draggedRampHandle = null; return; } draggedRampHandle.style.zIndex = 20; document.addEventListener('mousemove', handleLayerDrag, { passive: false }); document.addEventListener('mouseup', endRampDrag); event.preventDefault(); }
                function handleLayerDrag(event) { if (!isDraggingRampHandle || !draggedRampHandle || rampWidth <= 0) return; event.preventDefault(); const currentX = event.clientX; let newXRelativeToRamp = currentX - rampLeft; newXRelativeToRamp = Math.max(0, Math.min(rampWidth, newXRelativeToRamp)); let newPercent = (newXRelativeToRamp / rampWidth) * 100; newPercent = Math.max(0, Math.min(100, newPercent)); const layer = draggedRampHandle.dataset.layer; const currentBoundaries = getBoundariesFromRamp(); if (layer === 'grass') { newPercent = Math.max(newPercent, currentBoundaries.forest + MIN_RAMP_SEPARATION); } else if (layer === 'forest') { newPercent = Math.min(newPercent, currentBoundaries.grass - MIN_RAMP_SEPARATION); newPercent = Math.max(newPercent, currentBoundaries.stone + MIN_RAMP_SEPARATION); } else if (layer === 'stone') { newPercent = Math.min(newPercent, currentBoundaries.forest - MIN_RAMP_SEPARATION); } newPercent = Math.round(Math.max(0, Math.min(100, newPercent))); let newLeft = (newPercent / 100) * rampWidth - (draggedRampHandle.offsetWidth / 2); newLeft = Math.max(0, Math.min(rampWidth - draggedRampHandle.offsetWidth, newLeft)); draggedRampHandle.style.left = `${newLeft}px`; rampValueSpans[layer].textContent = `${newPercent}%`; const finalGrassPercent = (layer === 'grass') ? newPercent : currentBoundaries.grass; rampValueSpans.sand.textContent = `${Math.max(0, 100 - finalGrassPercent)}%`; if (selectedIslandId !== null) { throttledUpdateLayers(); } }
                function endRampDrag() { if (isDraggingRampHandle) { if (draggedRampHandle) { draggedRampHandle.style.zIndex = 10; } if (selectedIslandId !== null) { saveState("Update Layer Boundaries (Ramp Drag)"); updateIslandLayersOnly(); } } isDraggingRampHandle = false; draggedRampHandle = null; document.removeEventListener('mousemove', handleLayerDrag); document.removeEventListener('mouseup', endRampDrag); }

                // ==================================================
                // EVENT LISTENERS (Using simplified, proven toggle logic)
                // ==================================================
                window.addEventListener('resize', () => { requestAnimationFrame(() => { if (resizeCanvas(false)) { rampWidth = layerRamp.offsetWidth; updateSelectionState(); requestAnimationFrame(renderMap); } }); });
                document.addEventListener('keydown', (e) => { const activeEl = document.activeElement; if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable)) return; if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') { e.preventDefault(); saveMap(); } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') { e.preventDefault(); triggerLoadMap(); } else if (e.key === 'Escape') { if (activeHandle) endHandleDrag(); else if (isPlacingIsland) cancelPlacement(); else if (selectedIslandId !== null) { selectedIslandId = null; updateSelectionState(); } } else if (e.key === 'Delete' || e.key === 'Backspace') { if (selectedIslandId !== null) { deleteSelectedIsland(); } } else if (e.key.toLowerCase() === 'c') { e.preventDefault(); centerViewBtn.click(); } else if (e.key.toLowerCase() === 'p') { e.preventDefault(); if (isPlacingIsland) cancelPlacement(); else startIslandPlacement(); }
                 // Toolbar Toggle Shortcut
                 else if (e.key.toLowerCase() === 't') {
                     e.preventDefault();
                     editorApp.classList.toggle('toolbar-visible');
                     // Trigger resize/update after the CSS transition time
                     setTimeout(() => requestAnimationFrame(() => { resizeCanvas(true); rampWidth = layerRamp.offsetWidth; updateSelectionState(); }), 310);
                 }
                });
                canvas.addEventListener('wheel', (e) => { e.preventDefault(); const rect = canvas.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const wp1 = screenToWorld(sx,sy); const zoomAmount = e.deltaY * SCROLL_SENSITIVITY; const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, view.scale * (1 - zoomAmount))); view.scale = newScale; const wp2 = screenToWorld(sx,sy); if(!isNaN(wp1.x) && !isNaN(wp2.x)){ view.offsetX += wp1.x - wp2.x; view.offsetY += wp1.y - wp2.y; } updateZoomDisplay(); requestAnimationFrame(renderMap); }, { passive: false });
                canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const wp = screenToWorld(sx, sy); if(isNaN(wp.x)) return; lastMousePos = { screen: { x: sx, y: sy }, world: wp }; updateCoordsDisplay(sx, sy); if (activeHandle) { updateHandleDrag(wp); } else if (isPanning) { const dxScreen = sx - dragStartCoords.screen.x; const dyScreen = sy - dragStartCoords.screen.y; if(dragStartCoords.world){ view.offsetX = dragStartCoords.world.x - (dxScreen / view.scale); view.offsetY = dragStartCoords.world.y - (dyScreen / view.scale); requestAnimationFrame(renderMap); } } else if (isMovingIsland && selectedIslandId !== null) { const island = mapData.islands.find(isl => isl.id === selectedIslandId); if(island){ const worldDeltaX = wp.x - dragStartCoords.world.x; const worldDeltaY = wp.y - dragStartCoords.world.y; if(!isNaN(worldDeltaX) && !isNaN(worldDeltaY)){ moveIsland(island, worldDeltaX, worldDeltaY); dragStartCoords.world = wp; requestAnimationFrame(renderMap); } } } else if (isPlacingIsland) { updatePlacementPreview(wp); } else { const handleHit = hitTestHandles(wp); let isOverIsland = false; if (selectedIslandId !== null) { const selectedOuter = mapData.islands.find(isl => isl.id === selectedIslandId)?.layers?.find(l=>l.type==='sand')?.points; if (selectedOuter && pointInPolygon(wp, selectedOuter)) isOverIsland = true; } if (!isOverIsland) { isOverIsland = mapData.islands.some(island => { if (island.id === selectedIslandId) return false; const outerLayer = island.layers?.find(l=>l.type==='sand')?.points; return outerLayer && pointInPolygon(wp, outerLayer); }); } let cursor = 'grab'; if(handleHit) cursor = 'crosshair'; else if (selectedIslandId !== null && isOverIsland) cursor = 'move'; else if (isOverIsland) cursor = 'pointer'; canvasContainer.style.cursor = cursor; } });
                canvas.addEventListener('mousedown', (e) => { const rect = canvas.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const wp = screenToWorld(sx, sy); if(isNaN(wp.x)) return; dragStartCoords = { screen: { x: sx, y: sy }, world: wp }; const handleHit = hitTestHandles(wp); if (handleHit && e.button === 0) { startHandleDrag(handleHit, wp); return; } if (isPlacingIsland) { if (e.button === 0) finalizePlacement(); return; } if (e.button === 0) { if (selectIslandAt(wp)) { isMovingIsland = true; canvasContainer.style.cursor = 'move'; dragStartCoords.world = wp; } else { isPanning = true; canvasContainer.style.cursor = 'grabbing'; dragStartCoords.world = { x: view.offsetX, y: view.offsetY }; } } else if (e.button === 1 || (e.button === 0 && e.ctrlKey)) { isPanning = true; canvasContainer.style.cursor = 'grabbing'; dragStartCoords.world = { x: view.offsetX, y: view.offsetY }; } });
                canvas.addEventListener('mouseup', (e) => { if (activeHandle) { endHandleDrag(); } else if (isMovingIsland && selectedIslandId !== null) { saveState("Move Island"); } isPanning = false; isMovingIsland = false; const rect = canvas.getBoundingClientRect(); const sx=e.clientX-rect.left, sy=e.clientY-rect.top; const wp = screenToWorld(sx, sy); const handleHit = hitTestHandles(wp); let isOverIsland = false; if (selectedIslandId !== null) { const selectedOuter = mapData.islands.find(isl => isl.id === selectedIslandId)?.layers?.find(l=>l.type==='sand')?.points; if (selectedOuter && pointInPolygon(wp, selectedOuter)) isOverIsland = true; } if (!isOverIsland) { isOverIsland = mapData.islands.some(island => { if (island.id === selectedIslandId) return false; const outerLayer = island.layers?.find(l=>l.type==='sand')?.points; return outerLayer && pointInPolygon(wp, outerLayer); }); } let cursor = 'grab'; if (isPlacingIsland) cursor = 'crosshair'; else if(handleHit) cursor = 'crosshair'; else if (selectedIslandId !== null && isOverIsland) cursor = 'move'; else if (isOverIsland) cursor = 'pointer'; canvasContainer.style.cursor = cursor; });
                canvas.addEventListener('mouseleave', (e) => { if (activeHandle) endHandleDrag(); if (isPanning) isPanning = false; if (isMovingIsland) isMovingIsland = false; if (!isPlacingIsland) canvasContainer.style.cursor = 'grab'; if(coordsSpan) coordsSpan.textContent = '( - , - )'; });
                canvas.addEventListener('contextmenu', (e) => { // Restored Right-click preview
                    e.preventDefault();
                    if (isPlacingIsland) {
                        const rect = canvas.getBoundingClientRect();
                        const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
                        generatePreviewShape(screenToWorld(sx, sy));
                    } else {
                        const rect = canvas.getBoundingClientRect();
                        const sx=e.clientX-rect.left, sy=e.clientY-rect.top;
                        selectIslandAt(screenToWorld(sx, sy));
                    }
                });

                // --- Toolbar Toggle Buttons (Simplified Logic) ---
                toolbarCloseBtn.addEventListener('click', () => {
                    console.log("Close clicked"); // Basic log
                    editorApp.classList.remove('toolbar-visible');
                    // Trigger resize/update after the CSS transition time
                    setTimeout(() => requestAnimationFrame(() => { resizeCanvas(true); rampWidth = layerRamp.offsetWidth; updateSelectionState(); }), 310);
                });
                toolbarOpenBtn.addEventListener('click', () => {
                     console.log("Open clicked"); // Basic log
                    editorApp.classList.add('toolbar-visible');
                    // Trigger resize/update after the CSS transition time
                    setTimeout(() => requestAnimationFrame(() => { resizeCanvas(true); rampWidth = layerRamp.offsetWidth; updateSelectionState(); }), 310);
                });

                // --- Other Listeners (Keep as is) ---
                addIslandBtn.addEventListener('click', () => { if (isPlacingIsland) cancelPlacement(); else startIslandPlacement(); });
                removeIslandBtn.addEventListener('click', deleteSelectedIsland);
                saveBtn.addEventListener('click', saveMap);
                loadBtn.addEventListener('click', triggerLoadMap);
                loadFileElement.addEventListener('change', loadMap);
                undoBtn.addEventListener('click', undo);
                redoBtn.addEventListener('click', redo);
                centerViewBtn.addEventListener('click', () => { if (selectedIslandId !== null) { const island = mapData.islands.find(isl => isl.id === selectedIslandId); if (island?.center && !isNaN(island.center.x)) { centerViewOn(island.center.x, island.center.y); } else { resetViewToMapCenter(); } } else { resetViewToMapCenter(); } });
                fitViewBtn.addEventListener('click', fitViewToIslands);
                islandPointsInput.addEventListener('input', throttledRegenerate);
                islandRadiusNoiseInput.addEventListener('input', (e) => { radiusNoiseValueSpan.textContent = parseFloat(e.target.value).toFixed(2); throttledRegenerate(); });
                chaikinIterationsInput.addEventListener('input', (e) => { iterationsValueSpan.textContent = e.target.value; throttledRegenerate(); });
                islandPerlinAmpInput.addEventListener('input', (e) => { perlinAmpValueSpan.textContent = parseFloat(e.target.value).toFixed(2); throttledRegenerate(); });
                islandPerlinFreqInput.addEventListener('input', (e) => { perlinFreqValueSpan.textContent = parseFloat(e.target.value).toFixed(1); throttledRegenerate(); });
                layerRampContainer.addEventListener('mousedown', startRampDrag);

                // ==================================================
                // INITIALIZATION (Keep as is)
                // ==================================================
                function initialize() {
                    if (isInitialized) return;
                    console.log("Initializing Editor...");
                    radiusNoiseValueSpan.textContent = parseFloat(islandRadiusNoiseInput.value).toFixed(2);
                    perlinAmpValueSpan.textContent = parseFloat(islandPerlinAmpInput.value).toFixed(2);
                    perlinFreqValueSpan.textContent = parseFloat(islandPerlinFreqInput.value).toFixed(1);
                    iterationsValueSpan.textContent = chaikinIterationsInput.value;
                    rampWidth = layerRamp.offsetWidth;
                    if (rampWidth <= 0) { console.warn("Initial rampWidth calculation resulted in zero."); }
                    setRampHandles(DEFAULT_LAYER_BOUNDARIES);
                    islandCountSpan.textContent = '0'; removeIslandBtn.disabled = true; undoBtn.disabled = true; redoBtn.disabled = true; canvasContainer.style.cursor = 'grab';
                    if (typeof window.noise === 'undefined' || typeof window.noise.seed !== 'function') { console.error("CRITICAL: noisejs library failed!"); alert("Error: Noise library not found or invalid."); } else { window.noise.seed(Math.random()); }
                    if (!resizeCanvas(false)) { console.log("Initial canvas size matched container."); resetViewToMapCenter(); } else { console.log("Initial canvas resize performed."); rampWidth = layerRamp.offsetWidth; setRampHandles(DEFAULT_LAYER_BOUNDARIES); resetViewToMapCenter(); }
                    isInitialized = true; console.log("Editor ready.");
                }
                initialize(); // Start the editor initialization

            }); // End DOMContentLoaded listener callback
        } catch (err) {
            console.error("Unhandled synchronous error during script execution:", err);
            alert(`A critical error occurred during editor initialization: ${err.message}\n\nThe editor may not function correctly. Check the console (F12) for more details.`);
        }
    </script>

</body>
</html>
